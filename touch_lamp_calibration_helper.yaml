esphome:
  name: "smart-touch-1-calibration"
  friendly_name: Smart Touch Lamp 1 - Calibration Helper

esp32:
  board: esp32doit-devkit-v1
  # board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging - use DEBUG for raw touch pad values
logger:
  level: debug

# Enable Home Assistant API
api:
  # encryption:
  #   key: !secret api_key

ota:
  - platform: esphome
    # password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "FR-Lamp-Touch-Cal"
    password: !secret wifi_password

# Enable Web server for monitoring
web_server:
  port: 80

captive_portal:

# Touch sensor configuration
esp32_touch:
  setup_mode: true  # Set to true for calibration - shows raw values
  measurement_duration: 0.25ms

# ============================================================
# CALIBRATION HELPER SENSORS & COMPONENTS
# ============================================================

# Raw touch pad readings
# sensor:
#   # Raw touch pad value - shows live readings
#   - platform: esp32_touch
#     name: "Touch Pad Raw Value"
#     pin: GPIO13
#     id: touch_pad_raw
#     update_interval: 100ms
#     internal: false  # Make visible for monitoring
binary_sensor:
  - platform: esp32_touch
    name: "ESP32 Touch Pad GPIO13"
    pin: GPIO13
    threshold: 1000

# Global variables to store calibration data
# globals:
#   # Store the maximum raw value when NOT touching
#   - id: cal_no_touch_max
#     type: uint32_t
#     restore_value: no
#     initial_value: '0'
  
#   # Store the minimum raw value when touching
#   - id: cal_touch_min
#     type: uint32_t
#     restore_value: no
#     initial_value: '4294967295'  # Max uint32_t
  
#   # Calculated threshold
#   - id: calculated_threshold
#     type: uint32_t
#     restore_value: no
#     initial_value: '550000'
  
#   # Calibration state
#   - id: calibration_state
#     type: int
#     restore_value: no
#     initial_value: '0'  # 0=idle, 1=testing_no_touch, 2=testing_touch, 3=complete

# Text sensor to display calibration status and results
# text_sensor:
#   - platform: template
#     name: "Calibration Status"
#     id: calibration_status
#     update_interval: 500ms
#     lambda: |-
#       switch(id(calibration_state)) {
#         case 0:
#           return std::string("Idle - Press button to start");
#         case 1:
#           return std::string("Testing NO TOUCH - Keep pad clear");
#         case 2:
#           return std::string("Testing TOUCH - Repeatedly touch pad");
#         case 3:
#           return std::string("CALIBRATION COMPLETE");
#         default:
#           return std::string("Unknown state");
#       }

# Number component to display the "no touch" reference value
# number:
#   - platform: template
#     name: "No Touch Max Value"
#     id: no_touch_max_display
#     unit_of_measurement: "ADC"
#     min_value: 0
#     max_value: 4294967295
#     optimistic: true
#     disabled_by_default: false
#     lambda: |-
#       return id(cal_no_touch_max);

#   - platform: template
#     name: "Touch Min Value"
#     id: touch_min_display
#     unit_of_measurement: "ADC"
#     min_value: 0
#     max_value: 4294967295
#     optimistic: true
#     disabled_by_default: false
#     lambda: |-
#       return id(cal_touch_min);

#   - platform: template
#     name: "Recommended Threshold"
#     id: recommended_threshold
#     unit_of_measurement: "ADC"
#     min_value: 0
#     max_value: 4294967295
#     optimistic: true
#     disabled_by_default: false
#     lambda: |-
#       return id(calculated_threshold);

# ============================================================
# CALIBRATION BUTTONS & CONTROL
# ============================================================

button:
  # Start the calibration sequence - Phase 1: NO TOUCH
  # - platform: template
  #   name: "Start Calibration"
  #   id: start_calibration_btn
  #   on_press:
  #     - logger.log:
  #         format: "### CALIBRATION STARTED - PHASE 1: Testing NO TOUCH ###"
  #         level: INFO
  #     - globals.set:
  #         id: calibration_state
  #         value: '1'
  #     - globals.set:
  #         id: cal_no_touch_max
  #         value: '0'
  #     - globals.set:
  #         id: cal_touch_min
  #         value: '4294967295'

  # Transition from Phase 1 (no touch) to Phase 2 (touch testing)
  # - platform: template
  #   name: "End No-Touch Phase (Start Touch Phase)"
  #   id: end_no_touch_btn
  #   on_press:
  #     - logger.log:
  #         format: "### PHASE 1 COMPLETE ###"
  #         level: WARN
  #     - logger.log:
  #         format: "No-Touch Maximum Value: %d"
  #         args: ['id(cal_no_touch_max)']
  #         level: INFO
  #     - logger.log:
  #         format: "### CALIBRATION PHASE 2: Testing TOUCH ###"
  #         level: INFO
  #     - logger.log:
  #         format: "Repeatedly touch the pad for 10-15 seconds"
  #         level: WARN
  #     - globals.set:
  #         id: calibration_state
  #         value: '2'

  # Complete the calibration and calculate threshold
  # - platform: template
  #   name: "Complete Calibration"
  #   id: complete_calibration_btn
  #   on_press:
  #     - logger.log:
  #         format: "### CALIBRATION COMPLETE ###"
  #         level: WARN
  #     - logger.log:
  #         format: "Touch Minimum Value: %d"
  #         args: ['id(cal_touch_min)']
  #         level: INFO
  #     - logger.log:
  #         format: "No-Touch Maximum Value: %d"
  #         args: ['id(cal_no_touch_max)']
  #         level: INFO
  #     - lambda: |-
  #         uint32_t no_touch = id(cal_no_touch_max);
  #         uint32_t touch = id(cal_touch_min);
          
  #         // Calculate midpoint as threshold (75% of the way down from no-touch to touch)
  #         // This provides good hysteresis
  #         if (touch < no_touch) {
  #           uint32_t range = no_touch - touch;
  #           id(calculated_threshold) = no_touch - (range * 3 / 4);  // 75% down from no-touch
  #         }
  #     - logger.log:
  #         format: "Calculated Threshold: %d"
  #         args: ['id(calculated_threshold)']
  #         level: WARN
  #     - logger.log:
  #         format: "RECOMMENDED CONFIG: threshold: %d"
  #         args: ['id(calculated_threshold)']
  #         level: WARN
  #     - globals.set:
  #         id: calibration_state
  #         value: '3'

  # Reset calibration to start over
  # - platform: template
  #   name: "Reset Calibration"
  #   id: reset_calibration_btn
  #   on_press:
  #     - logger.log:
  #         format: "### CALIBRATION RESET ###"
  #         level: WARN
  #     - globals.set:
  #         id: calibration_state
  #         value: '0'
  #     - globals.set:
  #         id: cal_no_touch_max
  #         value: '0'
  #     - globals.set:
  #         id: cal_touch_min
  #         value: '4294967295'
  #     - globals.set:
  #         id: calculated_threshold
  #         value: '550000'

  # Restart ESP32
  - platform: restart
    name: "Restart ESP32"
    id: restart_btn

# ============================================================
# AUTOMATION: Capture sensor readings during calibration
# ============================================================

# automation:
#   # During Phase 1 (no touch): capture maximum value
#   - id: capture_no_touch_values
#     trigger:
#       component.update:
#         id: touch_pad_raw
#     condition:
#       lambda: 'return id(calibration_state) == 1;'
#     then:
#       - lambda: |-
#           uint32_t current = id(touch_pad_raw).state;
#           if (current > id(cal_no_touch_max)) {
#             id(cal_no_touch_max) = current;
#           }

#   # During Phase 2 (touch): capture minimum value
#   - id: capture_touch_values
#     trigger:
#       component.update:
#         id: touch_pad_raw
#     condition:
#       lambda: 'return id(calibration_state) == 2;'
#     then:
#       - lambda: |-
#           uint32_t current = id(touch_pad_raw).state;
#           if (current < id(cal_touch_min)) {
#             id(cal_touch_min) = current;
#           }
